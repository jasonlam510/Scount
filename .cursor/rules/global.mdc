
# Scount - Personal & Group Expense Tracker

## Project Overview:
- **Purpose**: Personal and group expense tracking application
- **Tech Stack**: React Native + Expo, TypeScript, Supabase (DB/Auth), PowerSync (sync engine)
- **Target Platforms**: iOS and Android (mobile-only)
- **Architecture**: Offline-first with real-time sync

## UI/UX Guidelines:
- **Theme System**: ALWAYS use theme colors from `useTheme()` hook - never hard-code colors
- **Mobile-First Design**: Design specifically for iOS and Android mobile platforms
- **Language Support**: Use i18n keys from `useI18n()` hook - support English and Chinese (繁體中文)
- **Native Components**: Use ActionSheetIOS for iOS, platform-specific components for Android
- **Accessibility**: Follow iOS Human Interface Guidelines and Android Material Design accessibility standards

## Code Style and Structure:
- Use concise functional React Native components with TypeScript
- Prefer hooks and Zustand stores for state management; avoid classes
- File structure: `src/{app, components, hooks, powersync, zustand, i18n, types, utils, contexts}`
- Navigation: Expo Router with file-based routing (`app/(tabs)`, `app/(auth)`)
- Component organization: Feature-based with atomic design:
  - `src/components/features/{feature}/sections/` - Screen-level composites
  - `src/components/features/{feature}/components/` - Reusable building blocks
  - `src/components/ui/` - Generic UI components
- Follow offline-first architecture: PowerSync for data sync, AsyncStorage for app settings

## EAS Build Compatibility:
- **Dependency Constraint**: ONLY use dependencies that are compatible with Expo EAS builds
- **Native Modules**: Avoid native modules that require custom native code or configuration
- **Expo SDK**: Prefer Expo SDK modules over third-party alternatives when available
- **No Custom Native Code**: Avoid libraries requiring custom iOS/Android native code modifications

## Data Layer (PowerSync + Supabase):
- **Database Schema**: Follow `docs/erd.md` for complete schema definition and relationships
- **Core Tables**: `profiles`, `groups`, `participants` (see ERD for full field specifications)
- **UUID Primary Keys**: All tables use UUID PKs as defined in ERD
- **PowerSync Hooks**: Use hooks from `src/powersync/hooks/` directory (`useUserGroups`, `useUserGroupsRealtime`)
- **Direct Database Access**: Use `db` from `@/powersync` directly in screens for simple queries
- **Query Patterns**: Use Kysely for type-safe queries, PowerSync handles sync automatically
- **Realtime Hooks**: Prefer `useUserGroupsRealtime` for reactive data updates
- **Sync Rules**: Define user-specific buckets in `sync-rules.yaml` following ERD relationships
- **Schema Mapping**: Mirror ERD structure in `src/powersync/AppSchema.ts` for local SQLite
- **Platform Support**: SQL.js adapter for Expo Go, native SQLite for production builds
- **No Auto-Create**: Never auto-create records in hooks; return null when not found

## Screen Architecture:
- **Location**: Screens are in `src/app/(tabs)/` or `src/app/(auth)/`
- **Structure**: Each screen file should contain:
  - State management for screen-specific data
  - Data fetching logic (useEffect hooks, db queries)
  - Business logic handlers (api calls, navigation)
  - Platform-specific handlers passed to components
- **Data Fetching**: Use `db` from `@/powersync` directly in screen useEffect hooks
- **Component Usage**: Import and use section components from `@/components/features/{feature}`

## Naming Conventions:
- **Component folders**: Each component lives in its own subfolder; folder name must match the component name exactly (including capitalized first letter), e.g. `ProfileScreen/ProfileScreen.tsx`, `SwitchRow/SwitchRow.tsx`
- **Grouping folders** (folders that group components or other files, not named after a single component): lowercase, no capital letter — kebab-case preferred (`components/expense-item`, `powersync/hooks`, `features/profile/sections`)
- **Files**: PascalCase for components (`ProfileScreen.tsx`), camelCase for hooks (`useProfile.ts`)
- **Database**: snake_case tables (`personal_expenses`, `user_id` columns)
- **Hooks**: Prefix with `use` (`useTheme`, `useUserGroups`, `useProfile`)
- **PowerSync**: Use `Realtime` suffix for reactive hooks (`useUserGroupsRealtime`)
- **Feature Components**: PascalCase (`ProfileSection.tsx`, `SwitchRow.tsx`)

## TypeScript Guidelines:
- Use interfaces for data models (Profile, Group, Participant, PersonalExpense)
- Define database types from PowerSync schema: `Database = (typeof AppSchema)['types']`
- Use string literals instead of enums for better JSON serialization
- Platform-specific typing: `Platform.OS === 'ios'` for conditional logic
- **Native vs web**: When logic differs significantly or different libraries are required, split by file extension: `.tsx` for native (iOS/Android), `.web.tsx` for web; bundler resolves the correct file per platform

## Component Design Principles:
- **Separation of Concerns**: 
  - Screen files: Business logic, state management, data fetching
  - Sections: Screen-level composition, platform-specific UI
  - Components: Reusable building blocks, pure presentation logic
- **Platform UI Handling**: Platform-specific UI (ActionSheetIOS vs Selector) goes in components
- **Business Logic**: Business logic, API calls, data updates stay in screen files
- **Component Props**: Components should receive business callbacks (`onPhotoSelected`, `onLogout`)
- **State Management**: Use local state for UI state, Zustand for app-wide state

## Platform-Specific Considerations:
- **iOS**: Use ActionSheetIOS, native styling, respect safe areas, follow Human Interface Guidelines
- **Android**: Use Material Design components, respect Android navigation patterns
- **Expo Go**: Use SQL.js adapter, avoid native modules
- **Development**: Support hot reload, clear console logging with platform tags
