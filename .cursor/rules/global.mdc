
# Scount - Personal & Group Expense Tracker

## REQUIRED CONTEXT (read before developing)

- **Project memory (repo-shared)**: Start with `.cursor/memory/MEMORY.md`
  - Repo conventions: `.cursor/memory/project-conventions.md`
  - Architecture notes: `.cursor/memory/architecture.md`
  - Dev commands: `.cursor/memory/dev-commands.md`
  - Cross-feature decisions: `.cursor/memory/dev-log.md`
- **Feature work**: If working on a feature scope, read `.cursor/scopes/<feature>/requirements.md` and `blueprint.md` first.

Keep this file focused on **non-negotiable rules**. Put evergreen “repo facts” and evolving conventions in `.cursor/memory/`.

## UI/UX Guidelines:
- **Theme System**: ALWAYS use theme colors from `useTheme()` hook - never hard-code colors
- **Theme Color Source of Truth**: Theme tokens live in `src/constants/colors.ts` (`lightColors` / `darkColors` via `colorThemes`)
- **Adding New Colors**: If a new color is required, add it to **both** `lightColors` and `darkColors` (and update `ThemeColors` if introducing a new key)
- **Mobile-First Design**: Design specifically for iOS and Android mobile platforms
- **Language Support**: Use i18n keys from `useI18n()` hook - support English and Chinese (繁體中文)
- **Native Components**: Use ActionSheetIOS for iOS, platform-specific components for Android
- **Accessibility**: Follow iOS Human Interface Guidelines and Android Material Design accessibility standards

## Code Style and Structure:
- Use concise functional React Native components with TypeScript
- Prefer hooks and Zustand stores for state management; avoid classes
- Prefer platform-specific files where behavior differs: `.web.tsx` vs `.tsx`
- Use `useI18n()` for user-facing strings and `useTheme()` for colors

## EAS Build Compatibility:
- **Dependency Constraint**: ONLY use dependencies that are compatible with Expo EAS builds
- **Native Modules**: Avoid native modules that require custom native code or configuration
- **Expo SDK**: Prefer Expo SDK modules over third-party alternatives when available
- **No Custom Native Code**: Avoid libraries requiring custom iOS/Android native code modifications

## Data Layer (PowerSync + Supabase):
- **Database Schema**: Follow `docs/erd.md` for complete schema definition and relationships
- **Core Tables**: `profiles`, `groups`, `participants` (see ERD for full field specifications)
- **UUID Primary Keys**: All tables use UUID PKs as defined in ERD
- **PowerSync Hooks**: Use hooks from `src/powersync/hooks/` directory (`useUserGroups`, `useUserGroupsRealtime`)
- **Direct Database Access**: Use `db` from `@/powersync` directly in screens for simple queries
- **Query Patterns**: Use Kysely for type-safe queries, PowerSync handles sync automatically
- **Realtime Hooks**: Prefer `useUserGroupsRealtime` for reactive data updates
- **Sync Rules**: Define user-specific buckets in `sync-rules.yaml` following ERD relationships
- **Schema Mapping**: Mirror ERD structure in `src/powersync/AppSchema.ts` for local SQLite
- **Platform Support**: SQL.js adapter for Expo Go, native SQLite for production builds
- **No Auto-Create**: Never auto-create records in hooks; return null when not found

## Screen Architecture:
- Screens use Expo Router under `src/app/` (see `.cursor/memory/architecture.md` for entry points).
- Keep business logic + data access in screen files; keep reusable presentation in components.

## Naming Conventions:
- **Component folders**: Each component lives in its own subfolder; folder name must match the component name exactly (including capitalized first letter), e.g. `ProfileScreen/ProfileScreen.tsx`, `SwitchRow/SwitchRow.tsx`
- **Grouping folders** (folders that group components or other files, not named after a single component): lowercase, no capital letter — kebab-case preferred (`components/expense-item`, `powersync/hooks`, `features/profile/sections`)
- **Files**: PascalCase for components (`ProfileScreen.tsx`), camelCase for hooks (`useProfile.ts`)
- **Database**: snake_case tables (`personal_expenses`, `user_id` columns)
- **Hooks**: Prefix with `use` (`useTheme`, `useUserGroups`, `useProfile`)
- **PowerSync**: Use `Realtime` suffix for reactive hooks (`useUserGroupsRealtime`)
- **Feature Components**: PascalCase (`ProfileSection.tsx`, `SwitchRow.tsx`)

## TypeScript Guidelines:
- Use interfaces for data models (Profile, Group, Participant, PersonalExpense)
- Define database types from PowerSync schema: `Database = (typeof AppSchema)['types']`
- Use string literals instead of enums for better JSON serialization
- Platform-specific typing: `Platform.OS === 'ios'` for conditional logic
- **Native vs web**: When logic differs significantly or different libraries are required, split by file extension: `.tsx` for native (iOS/Android), `.web.tsx` for web; bundler resolves the correct file per platform

## Component Design Principles:
- **Separation of Concerns**: 
  - Screen files: Business logic, state management, data fetching
  - Sections: Screen-level composition, platform-specific UI
  - Components: Reusable building blocks, pure presentation logic
- **Platform UI Handling**: Platform-specific UI (ActionSheetIOS vs Selector) goes in components
- **Business Logic**: Business logic, API calls, data updates stay in screen files
- **Component Props**: Components should receive business callbacks (`onPhotoSelected`, `onLogout`)
- **State Management**: Use local state for UI state, Zustand for app-wide state

## Platform-Specific Considerations:
- **iOS**: Use ActionSheetIOS, native styling, respect safe areas, follow Human Interface Guidelines
- **Android**: Use Material Design components, respect Android navigation patterns
- **Expo Go**: Use SQL.js adapter, avoid native modules
- **Development**: Support hot reload, clear console logging with platform tags
